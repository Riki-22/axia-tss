# Architecture Decision Records (ADR)

**Document Path**: `docs/architecture_dicision_records.md`  
**Created**: 2025-09-06  
**Version**: 1.0  
**Type**: ADR

## ADR-001: データストア3階層戦略の採用

**ステータス:** 決定済み  
**日付:** 2025-09-08

### 背景

- リアルタイム取引エンジンは、マイクロ秒〜ミリ秒単位での高速なデータアクセスを必要とする。
- 取引ログや注文履歴は、絶対に失われてはならない永続的なデータとして確実に保存する必要がある。
- 全てのヒストリカルデータは、コスト効率良く長期保存し、バッチ処理（バックテスト、分析）で利用できるようにする必要がある。
- これら3つの異なる要件（速度、信頼性、コスト）を単一のデータストアで満たすことは困難である。

### 決定

以下の3階層データ戦略を採用する。

1. **ホットデータ層（キャッシュ）:** ElastiCache for Redis を採用。最新のOHLCVデータ、現在のポジション、注文状態など、揮発性が高く、超高速なアクセスが求められるデータを保持する。

2. **ウォームデータ層（永続的状態）:** DynamoDB を採用。取引ログ、注文履歴など、一貫性と永続性が求められる確定済みのデータを保存する。

3. **コールドデータ層（長期保存）:** S3 を採用。全期間のヒストリカルデータやログのアーカイブを安価に保存する。

### 検討された代替案

**EC2インスタンス上のメモリをキャッシュとして利用:**
- **却下理由:** EC2インスタンスの再起動・クラッシュ時にデータが全て失われ、耐障害性が著しく低いため。

**DynamoDBをキャッシュとしても利用:**
- **却下理由:** ElastiCache for Redisと比較してレイテンシが大きく、リアルタイム性能要件を満たせない可能性がある。また、高頻度な読み書きによりコストが予測不能になるリスクがあるため。

**EC2ローカルディスクへのParquetファイル一時保存:**
- **却下理由:** ファイルI/Oのオーバーヘッドが非常に大きく、リアルタイムの更新処理に追いつけない。また、同時実行制御が複雑になるため。

## ADR-002: リポジトリパターンの採用

**ステータス:** 決定済み  
**日付:** 2025-09-08

### 背景

- ドメイン層のビジネスロジックを、特定のデータ永続化技術（DynamoDB, Redisなど）から完全に独立させる必要がある。
- ドメインロジックの単体テストを、実際のデータベース接続なしに高速かつ安定して実行できるようにする必要がある。
- キャッシュ戦略（例：まずRedisを試し、なければDynamoDBへ）を、ドメイン層やアプリケーション層に影響を与えずに実装する必要がある。

### 決定

ドメイン層に永続化のインターフェース（抽象基底クラス）を定義し、インフラストラクチャ層でその具象クラスを実装する「リポジトリパターン」を全面的に採用する。

### 期待される効果

- ユニットテスト時にインメモリの偽リポジトリを注入でき、テストの速度と信頼性が向上する。
- データストア技術の変更や追加がインフラ層の修正のみで完結し、システム全体の柔軟性と保守性が向上する。

## ADR-003: ドメインイベントの段階的導入

**ステータス:** 決定済み  
**日付:** 2025-09-08

### 背景

- システムの責務が複雑化するにつれて、一つのドメインロジック（例：取引実行）が、通知、パフォーマンス記録、リスク計算など、複数の異なる関心事を抱え込むリスクがある。
- 将来的に、特定の処理を非同期化・並列化し、システムの応答性やスループットを向上させる必要が出てくる可能性がある。

### 決定

ドメインイベントパターンを採用し、以下の3段階で段階的に導入を進める。

#### フェーズ1（初期実装）: インプロセス・同期イベント

- SQS/SNSは使用せず、シンプルなイベントディスパッチャクラスを実装し、同一プロセス内で同期的にイベントを処理する。
- **目的:** まずはコードレベルで「関心の分離」を実現する。

#### フェーズ2（性能改善時）: インプロセス・非同期イベント

- asyncioやThreadPoolExecutorを導入し、時間のかかるイベントハンドラをバックグラウンドで実行する。
- **目的:** メインスレッドをブロックせず、システムの応答性を向上させる。

#### フェーズ3（高負荷・高可用性対応時）: プロセス外・非同期イベント

- イベントの発行・購読をSQS/SNSに置き換え、各ハンドラを独立したLambda関数などで実装する。
- **目的:** システムのコンポーネントを完全に分離し、スケーラビリティと耐障害性を最大化する。

### 理由

- 初期段階から完全な非同期メッセージングを導入するのは過剰設計であり、システムの複雑性を不必要に増大させるため。
- 段階的アプローチにより、ROIを最大化しつつ、将来の拡張性を担保する。

## ADR-004: 段階的なネットワークセキュリティモデルの採用

**ステータス:** 決定済み  
**日付:** 2025-09-14

### 背景

AWSのセキュリティベストプラクティスではEC2インスタンスをプライベートサブネットに配置することが推奨されるが、これにはNATインスタンス/ゲートウェイが必須となり、月額の固定コストが発生する。

### 決定

プロジェクトのフェーズに応じて、ネットワーク構成を段階的に変更する。

#### フェーズ1 (デモ口座での開発・運用)

EC2インスタンスを**パブリックサブネット**に配置する。これによりNAT関連のコストを完全に排除する。セキュリティは、セキュリティグループを厳格に設定（SSHアクセス元IPの制限など）することで担保する。

#### フェーズ2 (本番口座への移行)

システムをリアルマネーで運用する前に、EC2インスタンスを**プライベートサブネットに移行**し、アウトバウンド通信のためにコスト効率の良い**NATインスタンス**(t4g.nano) を導入することを**必須要件**とする。

### 理由

- **コストとリスクのバランス:** デモ口座運用中は金銭的なリスクがゼロに近いため、コスト削減のメリットを優先する。
- **セキュリティの確保:** 本番運用に移行する際は、セキュリティを最優先とし、AWSのベストプラクティスに準拠した構成に切り替える。

### トレードオフ

- デモ環境は、本番環境と比較してセキュリティレベルが低下する（ただし、許容範囲内と判断）。
- 本番移行時に、ネットワーク構成の変更作業が発生する。


## ADR-005: 段階的GSI実装戦略を採用

**ステータス:** 決定済み  
**日付:** 2025-09-30

### 背景
当初の設計では5つのGSI（Global Secondary Index）を一度に作成する計画だったが、実装フェーズで以下の問題が判明した：

- 用途が不明確なGSIの存在
- GSI1（戦略別）、GSI4（シグナル別）は現時点で具体的な使用場面がない
  - 設計書ベースで作成したが、実際の要件が不明確
- コストの無駄
  - 使用しないGSIにも課金が発生
  - ALL projectionによる全データ複製でコストが増大

### 決定
- GSI1のみ作成：オープンポジション高速取得用
- YAGNI原則（You Ain't Gonna Need It）に従う
  - 確実に必要な機能のみ実装
  - 実際の使用パターンが明確になった時点で追加

GSI1の設計
```yaml
GSI1:
  用途: オープンポジションの高速取得
  
  キー設計:
    パーティションキー: gs1pk = "OPEN_POSITIONS"（固定値）
    ソートキー: gs1sk = "SYMBOL#<symbol>#<timestamp>"
  
  特性:
    - スパースインデックス（OPENステータスのみ）
    - Projection: INCLUDE（必要最小限の属性）
    
  投影属性:
    - position_id, symbol, side, status
    - size, entry_price, stop_loss, take_profit
    - current_price, unrealized_pnl
    - created_utc
```
### 実装ルール
- スパース性の活用

```python
   # ポジション作成時
   if status == 'OPEN':
       item['gs1pk'] = 'OPEN_POSITIONS'
       item['gs1sk'] = f'SYMBOL#{symbol}#{timestamp}'
   
   # ポジションクローズ時
   # gs1pk, gs1skを削除してインデックスから除外
```

## ADR-006: 4層キャッシュ戦略と段階的データアクセス統合の採用

**ステータス:** 決定済み  
**日付:** 2025-10-11

### 背景
市場データへのアクセスには、高速性・可用性・耐障害性・コスト効率・開発効率という
複雑な要件が存在する。

### 決定
4層キャッシュアーキテクチャと統合データプロバイダーパターンを採用。

- Streamlitチャート表示には**Redis chart (TTL: 3600秒)**を使用
- S3からの期間指定読み取り機能を追加実装
- data_collectorは日次実行のまま（長期データ収集）

#### 4層キャッシュアーキテクチャ

| 層 | 技術 | TTL | レイテンシ | 用途 |
|----|------|-----|-----------|------|
| **L1: Memory** | Python dict / cachetools | 60秒 | ~1ms | プロセス内の超高頻度アクセスデータ |
| **L2: Redis** | ElastiCache for Redis | 3600秒 | ~10ms | リアルタイムOHLCV、ポジション状態 |
| **L3: DynamoDB** | DynamoDB | 1年 | ~50ms | 取引履歴、注文状態（永続化） |
| **L4: S3** | S3 (Parquet) | 無期限 | ~200ms | ヒストリカルデータ、バックテスト用 |

#### データソースの統合戦略

複数のデータソースを透過的に扱うため、**MarketDataProvider**パターンを採用する。